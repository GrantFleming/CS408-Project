\chapter{Introducing The Type Systems}

<this section is to be expanded, corrected and otherwise de-guffed>

Here we will introduce the two typesystems that will be the focus of
our study for the remainder of of Part 1.

\section{Hindley-Milner}

Work on what we now refer to as the "Hindley-Milner" type system began
in the late 60s and grew to become the basis of many functional
languages such as ML and Haskell.

This system, like System F, incorporates parametric polymorphism as a
first class feature. It does, however, deal with the gory details of
its formalization in a very different way, allowing it to glean some
desirable properties that System F cannot claim.

Firstly, when we define polymorphic functions, we need not explictly
bind the type variables, and thus when we use them, we need not
explicitly provide a type parameter. Instead, Hindley introduces a
system of \textit{type-schemes} (types that may contain free type
variables) and defines a type as being a type-scheme that contains no
type variables. Milner refers to these concepts as polytypes and
monotypes respectively.

This has the consequence that a given term may have any number of
type-schemes, some more general than others, some more specific
allowing us some 'shades of grey' in our type system and allowing us
to commit to stating more or less about our values as the situation
requires. Hindley then presents the idea of a \textit{principle type
  scheme} (p.t.s) or the most general polytype, where all possible
types for a given term are instances of the p.t.s. Informally, any
type-scheme of a term can be created by performing some consistent
substitution for the type variables in the p.t.s. 

He then proves that any term for which you can deduce a type scheme,
has a p.t.s. and it is always possible to work out what the p.t.s. is
up to \textit{trivial instances} - instances that are equal up to the
consistent renaming of type variables.

The idea of being able to always infer the most general type of an
expression is a defining feature of this type system. Let us take a
moment to ponder the ramifications of this feature.

\subsection{No Type annotations in code}

In Hindley-Milner, there is no need for us to annotate the definitions
in our code with type information.

Since we can always infer the p.t.s (most general type-scheme) of
expressions we, as programmers, need not supply this type information
in code when we make our definitions. This can result in cleaner
looking code in some circumstances however there is an argument that
providing type information explicitly in the syntax of the language
serves as important documentation.

\subsection{Type Checking}

The type inference algorithm that is detailed in the Hindley-Milner
system is instrumental in the way types are checked.

In a system like System F, whenever we wish to apply a polymorphic
function, we must provide the type parameter first before providing
the value parameter so that we may type-check the provided value
parameter. With Hindley-Milner, as a direct consequence of its type
inference features, this is not necessary. Instead we can infer the
most general type of the function, and check that the supplied
argument is some instance of the functions input type. This is
generally regarded as a good thing, less we end up with code that
contains so much type information as to be rendered unreadable.

The classic example of such systems is the creation of lists in the
standard $cons/[]$ way. In a language with a type system akin to
System F, this may look
something like:

\begin{minted}{haskell}
  (cons Number 1 (cons Number 9 (cons Number 6 [])))  
\end{minted}

whereas if we can infer the most general type of $cons$ and
subsequently verify that the supplied input is some instance of this
type as in Hindley-Milner, the same expression might be written as:

\begin{minted}{haskell}
  (cons 1 (cons 9 (cons 6 [])))  
\end{minted}

We can see this difference reflected in the typing rules of the
systems by way of the following example on id:

\[\begin{array}{c@{\qquad}|@{\qquad}c}
      \mbox{Hindley-Milner}
      &
      \mbox{System F}
      \\\\
      id : \forall \alpha \cdot \alpha \to \alpha
      &
      id : \Delta \alpha \cdot \alpha \to \alpha
      \\\\
      id = \lambda x \cdot x
      &
      id = \Lambda t . \lambda x_t \cdot x
\end{array} \]

The type in the Hindley-Milner system can be proven by:


\[\begin{array}{c}
\mbox{\begin{prooftree}
        \hypo{x : \alpha \in x : \alpha}   
      \infer1[var]{x : \alpha \vdash x : \alpha}
    \infer1[abs]{\vdash \lambda x \cdot x : \alpha \to \alpha}
    \hypo{\alpha \notin free(\epsilon)}
   \infer2[gen]{\vdash \lambda x \cdot x : \forall \alpha \cdot
   \alpha \to \alpha}
\end{prooftree}}
\end{array} \]


The equivalent type in System F can be proven by:

\[\begin{array}{c}
\mbox{\begin{prooftree}
      \hypo{x : \alpha \in x : \alpha}
    \infer1[var]{x : \alpha \vdash x : \alpha}
   \infer1[abs]{\vdash \lambda x_t \cdot x : \alpha \to \alpha}
   \infer1[$\Delta$-abs]{\vdash \Lambda t . \lambda x_t \cdot
     x : \Delta \alpha \cdot \alpha \to \alpha}
\end{prooftree}}
\end{array} \]

In system F, this deduces the only type for $\Lambda t . \lambda x_t
\cdot x$ (up to the renaming of bound variables) however note that
because of the 'shades of grey' allowable as a result of type
specialization and generalization in Hindley-Milner we may
also deduce other type (schemes) for $\lambda x \cdot x$:

\[\begin{array}{c}
\mbox{\begin{prooftree}
            \hypo{x : \alpha \to \beta \in x : \alpha \to \beta}
        \infer1[var]{x : \alpha \to \beta \vdash x : \alpha \to \beta}   
        \infer1[abs]{\vdash \lambda x \cdot x : (\alpha \to \beta) \to
        (\alpha \to \beta)}
        \hypo{\beta \notin free(\epsilon)}        
    \infer2[gen]{\vdash \lambda x \cdot x : \forall \beta \cdot
      (\alpha \to \beta) \to (\alpha \to \beta)}
    \hypo{\alpha \notin free(\epsilon)}
   \infer2[gen]{\vdash \lambda x \cdot x : \forall \alpha . \forall
     \beta \cdot (\alpha \to \beta) \to (\alpha \to \beta)}
\end{prooftree}}
\end{array} \]

Where $\forall \alpha . \forall \beta \cdot
(\alpha \to \beta) \to (\alpha \to \beta) \sqsubseteq \forall \alpha \cdot
   \alpha \to \alpha$

If you wanted a term with an equivalent type in system F you would
need to create a new term $\Lambda t_1 . \Lambda t_2 . \lambda x_{t_1
  \to t_2} \cdot x}$

A full list of the typing rules for System F and Hindley-Milner are
available in appendices \ref{appendix:sysFrules} and
\ref{appendix:HMrules} respectively.

\subsection{Type checking via inference}

\subsection{Things to talk aboot}

SystemF vs HM, typing rules for abstraction

Three places type variable can be bound in HM

Type variables alone do not specify that something is a polytype. They
could be bound in the context, in which case they behave as
constants. i.e. the type $\alpha \to \alpha$ is a monotype and not the
same as $\forall \alpha \cdot \alpha \to \alpha$. With a polytype, we
can use it in a let expression so that every where we use an
expression, we 'collapse' it's type to a some monotype that we want to
compute at (or perhaps 'collapse' it to another polytype)

In HM, the expression
$$let\; I\; =\; \lambda x . x\; in\; I I$$
is typable yet the semantically equivalent
$$(\lambda I . I\; I) (\lambda x . x)$$
is not. In System F, neither is typeable (I mean the first doesn't
exist but still). In HM, more things are typeable?

Limitations of HM? Self application is ill typed ... $\lambda
x . x x$ so, for instance, Y combinator is not typable.

$let F(f) = \lambda (a,b) . (f(a), f(b))$ is not typeable so we cannot
have generic $F(reverse)(x,y)$

we must instead write a specific $let\; reversepair = \lambda (x,y)
. (reverse(x), reverse(y))$

Example of let vs lambda bindings. Terms bound by lambdas are treated
as having monomorphic types, there type is fixed at the time it is
inferred and everywhere the term is used it must have exactly this
type. In let bindings, the type is inferred and everywhere the bound
variable is used, a different instantiation of the type may be
inferred.
E.g. in Haskell:

\begin{minted}{Haskell}
  -- this will not typecheck
  f = (\ i -> (i 3 , i "string")) id
  
  -- whereas this will
  g = let i = id in (i 3 , i "string")
\end{minted}

Haskell differs from HM in that all type variables are implicitly
$\forall$ quantified, in HM free type variables are allowable where
they may be 'bound' by the context. Not sure I understand this ...

The type of the only value in $\bbmath{W}=\{\cot\}$ (a.k.a. 'wrong')
has no type. I wonder if this is instrumental in deciding this type
system ... hmmmm need to give this more thought. If a well-typed
functions is applied to a well-typed argument, it will produce the
right type of result. It cannot go 'wrong'.

\section{Martin L\"{o}f}
