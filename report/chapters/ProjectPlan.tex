\chapter{Project plan}

\section{Project specification}

  \subsection{Overview}

  Writing type-checkers for compilers is a key task in the
  development and evolution of programming languages.

  Despite huge variety in the kinds of languages in existence,
  type-systems can often be described using the same kinds of
  basic elements such as typing rules. The descriptions have become
  standardised enough for us to recognise common syntax for
  describing these aspects in literature.

  This project seeks to capitalize on this by abstracting
  the common elements and asking the user to provide only what is
  specific to the type system they seek to represent. Given any
  description of a type-system in a specified format, a
  type-checker-generator should be able to generate a
  type-checker for the type system and use it to type-check provided
  source code.
  
  \subsection{Goal}

  To design a domain specific language (DSL) capable of describing type systems and to
  write a piece of software that, given one of these
  descriptions, is able to type-check code in the language
  it describes.

  \subsection{Artifacts}
  \label{section-artifacts}

  At a minimum, the finished project will consist of:

  \begin{itemize}
  \item A type-checker generator as a standalone binary
  \item At least two example specifications in the DSL
  \item At least two source code examples for each
    specification, one which type-checks successfully and one
    which does not
  \item The final report
  \end{itemize}
  
  \subsection{Scope}
  \label{sec-scope}

  \begin{center}
  \begin{tabular}{p{20em}|p{18em}}
    \large In Scope & \large Not In Scope \\ \hline \hline
    Notification on whether the type-checking succeeds
    or fails
    & Detailed feedback from the type-checking process \\ \hline
    Notification on whether or not the specification file is
    successfully parsed
    & Detailed feedback on the parsing of the specification file \\ \hline
    Example specifications and checkable code for small 'toy' languages
    & Example specifications and code for large 'real world' languages \\ \hline
    Single usable feature of 'running' the generator on a
    specification and piece of source code
    & Quality of life / usability features or other niceties \\ \hline
  \end{tabular}            
  \end{center}        
  
  \subsection{Milestones}
  \label{section-milestones}

  \begin{enumerate}
  \item A DSL that we are able to use to write \emph{specifications}
    of type systems
  \item A type-checker able to check types for a generic syntax
    using a \emph{fixed} set of typing rules where the checkable
    source code is supplied hard-coded.
  \item A type-checker able to check types when full type-system
    specifications and checkable source code is hard-coded.
  \item A type-checker  that checks types, reading
    the specification and source code from files.
  \end{enumerate}
  
  \subsection{Acceptance criteria}
  \label{sec-acceptance}

  \begin{enumerate}
  \item The software can be ran from the command-line by
    giving a simple command such as: $$\mbox{TypeCheck} \;
    <\emph{specification-file}> \;
    <\emph{source-code-file}>$$
  \item The software either succeeds with a simple indication
    message, or fails with one of two kinds of error:
    \begin{itemize}
    \item Failure to parse specification
    \item Failure to successfully type-check source code
    \end{itemize}
  \item The software passes a fixed set of test cases (specifications and
    source codes) succeeding, failing and showing
    appropriate errors as detailed in the test cases.
  \item The software can generate type-checkers capable of
    checking both non-dependent and dependent types.
  \end{enumerate}

\section{Timeline}

The following timeline assigns provisional deadlines to key stages in
the project. We will use this information later when we retroactively
evaluate our personal performance. 

\begin{center}
\begin{vtimeline}[description={text width=11cm}, 
 row sep=3em]
16/11/2020 & Complete initial readings on type-theory. \endlr
30/11/2020 & Complete specific readings relating to the design and
  implementation of various type systems and components thereof.\endlr
07/12/2020 & Identify all elements needed to fully and
  unambiguously describe a type system. \endlr
28/12/2020 & Design a DSL, formalising a syntax for expressing these
elements. \endlr
04/01/2020 & Produce sample specifications for testing using the DSL. \endlr
01/03/2021 & Design and implement a type-checker-generator. \endlr
15/03/2021 & Verify and test the implementation. \endlr
22/03/2021 & Conduct a qualitative evaluation of the DSL and resulting
software.\endlr
\end{vtimeline}          
\end{center}
\hrule

\section{Documentation}

The process of creating documentation for the project is intertwined
with the process of developing the code. We plan to create the source
code in literate Agda files, where source files are actually latex
files interespersed with areas identified as code.

By developing the code in this manner, we somewhat blur the lines
between implementation, documentation and reporting as we develop
aspects of all three simultaniously resulting in code that is self
documented. We do not consider a user-guide as necessary since running
the software consists of running a binary and supplying paths to some
specification file and some source code file. We will ensure the
software provides appropriate feedback if such files are not
identified.
