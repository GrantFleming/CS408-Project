\chapter{A Language for Describing Type Systems}

\section{What needs be described}

We provide means to describe a class of languages where all types
exist in a single universe. Although we could allow the user to
provide some name for the universe, we opt not to for simplicity.

In order to build a type checker for the language, the user must have
means to provide the following information:

\begin{itemize}
  \item Types
  \item Language constructs for each type, defining the 'shape' of
    all values of the associate type in weak head normal form
  \item A type-checking rule for each new language construct
  \item Eliminators
  \item Type synthesis rules for each elimination
  \item Beta reduction for each elimination
  \item Optional eta-expansion for each type
\end{itemize}

\section{Determining appropriate eliminations}
\label{appr-elim}

It may seem tempting to enforce certain eliminations. We might have
thought to treat type-parameterised types as assigning a type to each
subterm in a value. For every function, function types assign a type to
the newly bound variable and one to the body, for every pair, product
types assign a type to each element. With this in might we could have
enforced that exactly one eliminator exists for each such
sub-type/sub-term that allows access to this part of the term. This
train of thought seems sensible and initially appears to hold up to
scruitiny.

Following this train of thought further we might consider how we could
deduce $\eta$-expandability from such well-behaved types and
eliminations , however, when we consider sum types then this idea
falters. If we wishted to eta-expand a sum type, how would we know
which constructor to use without peeking at the structure of the
original term? There does not appear to be a way that be might choose
a constructor/eliminator pair that would work to eta-expand an
arbitrary term of the sum type.

As a result, we do not place such restrictions on which eliminators
must exist, and we put the onus on the user to supply enough
information for us to generate the eta-rules where necessary.

\section{The high level structure of descriptions}

\begin{itemize}
    \item One or more type descriptions where each is:
      \begin{itemize}
      \item type pattern
      \item premises for type rule
      \item Zero or more elimination descriptions where each is:
        \begin{itemize}
        \item eliminator pattern
        \item premises for type synthesis
        \item elimination type            
        \end{itemize}        
      \item Zero or more construction descriptions that provide the
        terms of this type. Each construction description is:
        \begin{itemize}
        \item construction pattern
        \item premises for type checking
        \item the $\beta$-reduced term for every elimination described
        \end{itemize}
      \item Zero or one $\eta$-expansion rules
      \end{itemize}
     
\end{itemize}

\section{Representing Patterns}

We require meta-level variables to represent arbitrary subterms in a
pattern. We adopt the convention that meta-level variables are always
upper case and so when we speak of identifiers in this section, we are
referring to strings of uppercase alpha-numeric characters. Newly bound
variables are denoted by an identifier postfixed with a period,
meta-level term variables are simply an identifier. All meta-level
variables must be separated from the rest of the pattern by
whitespace. All other characters are assumed to be literals and are
parsed as atoms except for parenthesis. We may, for example, describe
a pattern representing lambda terms as follows:

$$
\mbox{\textbackslash}\;  X. \; ->\; BODY}
$$

Where "\textbackslash" and "-$>$" are interpreted as the literal string
of characters, "X." is interpreted as a newly bound variable and
"BODY" represents an arbitrary sub-term. The scope of the newly bound
variable is assumed to extend rightward across the remainder of the
term, if this is not desirable then we may manipulate the structure of
the tree with parenthesis as one might expect, limiting the scope as
in the following example where "X" is not in scope in "ANOTHERSUBTERM".

$$
\mbox{\textbackslash}\;  (X. \; ->\; BODY) \; and \; ANOTHERSUBTERM}
$$

\section{Representing Expressions}
  
An expression introduces a way for users to build terms from
patterns that we decide are in-scope, the internal representation
always combines such patterns into a single pattern. When we later
define the structure of the DSL in more detail, we will make it clear
what patterns are in-scope where an expression is requested.

In defining an expression, we may define atoms of the expression, the
string literals, in the same way that we did for patterns. We may
place multiple elements side by side separated by whitespace (again in
the same way that we did for our patterns) and use the same encoding
for variables, newly bound variables are encoded with an identifier
postfixed with a period. We may refer to bound variables by giving the
appropriate identifier \emph{prefixed} with a period. Since we require
no meta-level sub-expression variables, we assume that any identifier
standing alone and un-postfixed is intended to refer to a meta-level
term variable of some pattern that is in-scope. Furthermore we may store
along-side this meta-term-variable, some substitution of the variables
that might occur in this term. Thus when we later instantiate the
pattern to an actual piece of syntax we might build an actual concrete
term from the instructions encoded as our expression. Hence these term
variables are always encoded in an expression with a substitution
where the variable and substitution are separated with a "/".

We must also devise a syntax to describe substitutions themselves,
we do so by simply giving substitutions as a list surrounded by square
brackets, each substitution separated by a comma, and each
substitution denoted by a reference to a bound variable (in the period
prefixed manner previously described) followed by "=" and the
expression that is to be substituted for this variable in the term.
All patterns in-scope for the parent expression are in-scope for this
child expression. The empty substitution is ommitted entirely and so
it should be written simply "VAR" when one might have written "VAR/[]".

Expressions can be used not only to build constructions, but to
express computations too. computations are embedded by surrounding
them with curly braces. They may consist of references to in-scope
variables which are denoted by the appropriate identifier
\emph{prefixed} with a period. They may also be an expression
representing a term and another representing its type separated by a
colon or a computation followed by some whitespace and a construction
to encode the elimination of the computation.

We give some example of expressions below giving the in-scope patterns
to the left of the "$\Rightarrow$" separated by commas and the
expression to the right of it. The patterns are only given in this
manner to give context for the benefit of the reader, the
$\Rightarrow$ notation is not part of our DSL.

\begin{align*}
  \mbox{\textbackslash}\; X. \; -> M \; , \; E \;
  &\Rightarrow \qquad M/[.X =
    E] \\
  \mbox{\textbackslash}\; X. \; -> M \;
  &\Rightarrow \qquad \mbox{\textbackslash}\; Y. \; -> M/[.X = .Y] \\
  \mbox{\textbackslash}\; X. \; -> M \;
  &\Rightarrow \qquad \mbox{\textbackslash}\; X. \; -> M/[.X = .X] \\  
\end{align*}

It is important to note the subtleties in scope when construction
expressions. In the last example, the "X." in the expression does not
shadow the "X." in the pattern, they exist in different scopes. In
this example, the substitution is not an identity substitution as it
might appear to be. Bound variables to the left of "=" are scoped to
the in-scope patterns, whereas on the right hand side, variables are
scoped to those bound in the expression, or as we will see later, a
variable name in a context extension. Furthermore we are not able
to give any expression on the right side of the "=" in the
substitution, we may only give a computation: either a variable, an
elimination or a type-annotated construction.

\section{Representing premise}

There are five kinds of premise representable in the DSL. Premise are
listed together one after another, chained, in order to give the
conditions under which we may make some judgement.

We will first detail each type of premise before discussing what it
means to chain the premise together and how we determin the scope of a
premise. We will also later detail what is considered in-scope when
defining an expression, and so we gloss over this when detaililng the
premises here.

The type premise is written by stating the word "type" followed by
the identifier corresponding to some meta level term variable in
scope.

$$
type \;\; SOMETERM
$$

The type check premise is written as some expression, followed by "<-"
and some identifier corresponding to a meta level term variable in
scope.

$$
someexpression \;\;<-\;\; SOMETERM
$$

The equivalence premise is written as an expression followed by "="
and another expression.

$$
someexpression \;\;=\;\; anotherexpression
$$

The context extension premise is written as some binder identifier,
followed by "=" and an expression followed by "$|-$" and another
premise. I.e. it allows to to present an arbitrary premise in the
extended context.

$$
.X = someexpression \;\;|-\;\; SOME/[] \;\;<-\;\; OTHERPREMISE
$$

The context extension premise is somewhat different in that its use is
mandated if we wish to present a premise talking about some meta-level
term variable that exists under a binder in the original pattern.

A chain of premises are always considered in the context of some
pattern, the subject. A chain of premises also begins with some
trusted pattern, the nature of this pattern depends on were we are
using the chain of premise and will be detailed later. The purpose of
a chain of premise is to obtain trust in the subject by describing how
to obtain trust in each of the meta-level term variables. There are
two ways that we can discharge such a variable as trusted: we can
state the type of the term variable with a type check premise, or we
can state that the term variable is a type with the type premise.

What is considered in-scope for the rightmost term variable in the
type premise and type check premise is all term variables in the
subject, provided they have not been discharged already earlier in the
chain. What term-variables are considered in-scope when constructing
expressions are those which are in-scope given the purpose for which
we are constructing the premise chain (this will be detailed later)
and every term variable in which we have established trust earlier in
the chain. In other words, all the term variables that appear as right
hand sides of type premise or type checking premise that appear
previously in the chain.

The initial scopes of a premise chain, that is the patterns where we
may reference meta term variables without establishing any trust,
differ depending on the purpose for which we are building the chain.

If the chain is given for the type rule, then there is nothing in
scope to begin with. If it is given for a type checking rule for some
construction, then the pattern describing the type is in scope when
constructing expressions in the chain. Finally, if the chain is given
for an elimination rule, then the pattern describing the type of the
target is in-scope when constructing expressions in the chain.

\section{$\eta$-expansion rules}

In order for us to perform $\eta$-expansion, there are two pieces of
information that we must have.

Firstly, we must know the top-level data constructor of a newly
$\eta$-expanded term. This is the very reason that we cannot
$\eta$-expand sum types as described previously. 

Secondly, for each argument to the data constructor, we must know the
eliminator which we might use such that when we eliminate the original
term with the eliminator, we get the term that is supplied as the
argument.

We can therefore give enough information to facilitate
$\eta$-expansion by choosing a pattern representing some value, and
giving an environment for the pattern, where an environment is
structurally identical except that it has a term everywhere the
original pattern had a term variable.

For instance, given the produce type $A \; x \; B$ with eliminators
$fst$ and $snd$ which describes values $X , Y$ then we might give $fst
, snd$ to inform the construction of an $\eta$-expansion rule. Similarly,
for a function type $A \; -> \; B$ with eliminator $E$ which describes
values $\setminus X. \; -> \; M$ then we might give $\setminus Y. \;
-> \; Y$ to inform the construction of an $\eta$-expansion rule.

\hl{should we further restrict types to single values in an
  eta-expanded situation?}

\section{The DSL}

As previously explained, the top level definition in our DSL
associates a patterns with a type. Every part of the definition
afterward is indented by 2 spaces.

If premises are required (that is to say, if the pattern contains meta
level term variables) then we add an "if:" clause, and then we list
the premises, indented again, on a new line, with each premise on a
line of its own.

We then provide

\section{As a CFG}
